/**
 * Generated by orval v6.9.6 üç∫
 * Do not edit manually.
 * Mantik minimal API
 * The API serves the front end with all necessary information on projects, and users.
 * OpenAPI spec version: 0.1.0
 */
import axios from 'axios'
import type { AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios'
import { useQuery, useMutation } from 'react-query'
import type {
    UseQueryOptions,
    UseMutationOptions,
    QueryFunction,
    MutationFunction,
    UseQueryResult,
    QueryKey,
} from 'react-query'
import type {
    GetUsers200,
    GetUsersParams,
    PutUsers201,
    PutUsersBody,
    User,
    GetUsersUserIdSettings200,
    UserSettings,
    GetProjects200,
    GetProjectsParams,
    PutProjects201,
    Project,
    GetProjectsUserUserId200,
    GetProjectsUserUserIdParams,
    GetProjectsProjectIdSettings200,
    ProjectSettings,
    GetProjectsProjectIdCode200,
    GetProjectsProjectIdCodeParams,
    PutProjectsProjectIdCode201,
    CodeRepository,
    GetProjectsProjectIdCodeUsage200,
    GetProjectsProjectIdCodeUsageParams,
    GetProjectsProjectIdCodeCodeRepositoryIdSettings200,
    CodeRepositorySettings,
    GetProjectsProjectIdData200,
    GetProjectsProjectIdDataParams,
    PutProjectsProjectIdData201,
    DataRepository,
    GetProjectsProjectIdDataUsage200,
    GetProjectsProjectIdDataUsageParams,
    GetProjectsProjectIdDataDataRepositoryIdSettings200,
    DataRepositorySettings,
    GetProjectsProjectIdExperiments200,
    GetProjectsProjectIdExperimentsParams,
    PutProjectsProjectIdExperiments201,
    ExperimentRepository,
    GetProjectsProjectIdExperimentsUsage200,
    GetProjectsProjectIdExperimentsUsageParams,
    GetProjectsProjectIdModels200,
    GetProjectsProjectIdModelsParams,
    PutProjectsProjectIdModels201,
    ModelRepository,
    GetProjectsProjectIdModelsUsage200,
    GetProjectsProjectIdModelsUsageParams,
    GetProjectsProjectIdRuns200,
    GetProjectsProjectIdRunsParams,
    PutProjectsProjectIdRuns201,
    AddRun,
    GetProjectsUserUserIdSearch200,
    GetProjectsUserUserIdSearchParams,
    GetProjectsProjectIdDeployments200,
    GetProjectsProjectIdDeploymentsParams,
    PutProjectsProjectIdDeployments201,
    DeploymentInformation,
    PackagedDeployment,
    PredictionResponse,
    PredictionRequest,
    GetGroups200,
    GetGroupsParams,
    PutGroups201,
    UserGroup,
    GetOrganizations200,
    GetOrganizationsParams,
    PutOrganizations201,
    Organization,
    GetLabels200,
    GetLabelsParams,
    Label,
    GetLabelsScope200,
    GetLabelsScopeParams,
    GetLabelsSearch200,
    GetLabelsSearchParams,
} from '.././models'

/**
 * List of all users (admin only)
 * @summary List of all users
 */
export const getUsers = (
    params?: GetUsersParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetUsers200>> => {
    return axios.get(`/users`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetUsersQueryKey = (params?: GetUsersParams) => [
    `/users`,
    ...(params ? [params] : []),
]

export type GetUsersQueryResult = NonNullable<
    Awaited<ReturnType<typeof getUsers>>
>
export type GetUsersQueryError = AxiosError<unknown>

export const useGetUsers = <
    TData = Awaited<ReturnType<typeof getUsers>>,
    TError = AxiosError<unknown>
>(
    params?: GetUsersParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getUsers>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetUsersQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({
        signal,
    }) => getUsers(params, { signal, ...axiosOptions })

    const query = useQuery<Awaited<ReturnType<typeof getUsers>>, TError, TData>(
        queryKey,
        queryFn,
        queryOptions
    ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Creates a new user
 */
export const putUsers = (
    putUsersBody: PutUsersBody,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<PutUsers201>> => {
    return axios.put(`/users`, putUsersBody, options)
}

export type PutUsersMutationResult = NonNullable<
    Awaited<ReturnType<typeof putUsers>>
>
export type PutUsersMutationBody = PutUsersBody
export type PutUsersMutationError = AxiosError<unknown>

export const usePutUsers = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof putUsers>>,
        TError,
        { data: PutUsersBody },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof putUsers>>,
        { data: PutUsersBody }
    > = (props) => {
        const { data } = props ?? {}

        return putUsers(data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof putUsers>>,
        TError,
        { data: PutUsersBody },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns the information on a specific user
 */
export const getUsersUserId = (
    userId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<User>> => {
    return axios.get(`/users/${userId}`, options)
}

export const getGetUsersUserIdQueryKey = (userId: string) => [
    `/users/${userId}`,
]

export type GetUsersUserIdQueryResult = NonNullable<
    Awaited<ReturnType<typeof getUsersUserId>>
>
export type GetUsersUserIdQueryError = AxiosError<unknown>

export const useGetUsersUserId = <
    TData = Awaited<ReturnType<typeof getUsersUserId>>,
    TError = AxiosError<unknown>
>(
    userId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getUsersUserId>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetUsersUserIdQueryKey(userId)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getUsersUserId>>
    > = ({ signal }) => getUsersUserId(userId, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getUsersUserId>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!userId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Update user info
 */
export const postUsersUserId = (
    userId: string,
    user: User,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(`/users/${userId}`, user, options)
}

export type PostUsersUserIdMutationResult = NonNullable<
    Awaited<ReturnType<typeof postUsersUserId>>
>
export type PostUsersUserIdMutationBody = User
export type PostUsersUserIdMutationError = AxiosError<unknown>

export const usePostUsersUserId = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof postUsersUserId>>,
        TError,
        { userId: string; data: User },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof postUsersUserId>>,
        { userId: string; data: User }
    > = (props) => {
        const { userId, data } = props ?? {}

        return postUsersUserId(userId, data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof postUsersUserId>>,
        TError,
        { userId: string; data: User },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns the settings for a specific user
 */
export const getUsersUserIdSettings = (
    userId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetUsersUserIdSettings200>> => {
    return axios.get(`/users/${userId}/settings`, options)
}

export const getGetUsersUserIdSettingsQueryKey = (userId: string) => [
    `/users/${userId}/settings`,
]

export type GetUsersUserIdSettingsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getUsersUserIdSettings>>
>
export type GetUsersUserIdSettingsQueryError = AxiosError<unknown>

export const useGetUsersUserIdSettings = <
    TData = Awaited<ReturnType<typeof getUsersUserIdSettings>>,
    TError = AxiosError<unknown>
>(
    userId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getUsersUserIdSettings>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ?? getGetUsersUserIdSettingsQueryKey(userId)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getUsersUserIdSettings>>
    > = ({ signal }) =>
        getUsersUserIdSettings(userId, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getUsersUserIdSettings>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!userId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Updates user settings
 */
export const postUsersUserIdSettings = (
    userId: string,
    userSettings: UserSettings,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(`/users/${userId}/settings`, userSettings, options)
}

export type PostUsersUserIdSettingsMutationResult = NonNullable<
    Awaited<ReturnType<typeof postUsersUserIdSettings>>
>
export type PostUsersUserIdSettingsMutationBody = UserSettings
export type PostUsersUserIdSettingsMutationError = AxiosError<unknown>

export const usePostUsersUserIdSettings = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof postUsersUserIdSettings>>,
        TError,
        { userId: string; data: UserSettings },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof postUsersUserIdSettings>>,
        { userId: string; data: UserSettings }
    > = (props) => {
        const { userId, data } = props ?? {}

        return postUsersUserIdSettings(userId, data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof postUsersUserIdSettings>>,
        TError,
        { userId: string; data: UserSettings },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns all projects (admin only)
 */
export const getProjects = (
    params?: GetProjectsParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjects200>> => {
    return axios.get(`/projects`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsQueryKey = (params?: GetProjectsParams) => [
    `/projects`,
    ...(params ? [params] : []),
]

export type GetProjectsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjects>>
>
export type GetProjectsQueryError = AxiosError<unknown>

export const useGetProjects = <
    TData = Awaited<ReturnType<typeof getProjects>>,
    TError = AxiosError<unknown>
>(
    params?: GetProjectsParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjects>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetProjectsQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjects>>> = ({
        signal,
    }) => getProjects(params, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjects>>,
        TError,
        TData
    >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
        queryKey: QueryKey
    }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Creates a new project
 */
export const putProjects = (
    project: Project,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<PutProjects201>> => {
    return axios.put(`/projects`, project, options)
}

export type PutProjectsMutationResult = NonNullable<
    Awaited<ReturnType<typeof putProjects>>
>
export type PutProjectsMutationBody = Project
export type PutProjectsMutationError = AxiosError<unknown>

export const usePutProjects = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof putProjects>>,
        TError,
        { data: Project },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof putProjects>>,
        { data: Project }
    > = (props) => {
        const { data } = props ?? {}

        return putProjects(data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof putProjects>>,
        TError,
        { data: Project },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns all projects for user with userId
 */
export const getProjectsUserUserId = (
    userId: string,
    params?: GetProjectsUserUserIdParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsUserUserId200>> => {
    return axios.get(`/projects/user/${userId}`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsUserUserIdQueryKey = (
    userId: string,
    params?: GetProjectsUserUserIdParams
) => [`/projects/user/${userId}`, ...(params ? [params] : [])]

export type GetProjectsUserUserIdQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsUserUserId>>
>
export type GetProjectsUserUserIdQueryError = AxiosError<unknown>

export const useGetProjectsUserUserId = <
    TData = Awaited<ReturnType<typeof getProjectsUserUserId>>,
    TError = AxiosError<unknown>
>(
    userId: string,
    params?: GetProjectsUserUserIdParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsUserUserId>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsUserUserIdQueryKey(userId, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsUserUserId>>
    > = ({ signal }) =>
        getProjectsUserUserId(userId, params, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsUserUserId>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!userId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Returns the information on a specific project
 */
export const getProjectsProjectId = (
    projectId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<Project>> => {
    return axios.get(`/projects/${projectId}`, options)
}

export const getGetProjectsProjectIdQueryKey = (projectId: string) => [
    `/projects/${projectId}`,
]

export type GetProjectsProjectIdQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectId>>
>
export type GetProjectsProjectIdQueryError = AxiosError<unknown>

export const useGetProjectsProjectId = <
    TData = Awaited<ReturnType<typeof getProjectsProjectId>>,
    TError = AxiosError<unknown>
>(
    projectId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsProjectId>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ?? getGetProjectsProjectIdQueryKey(projectId)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectId>>
    > = ({ signal }) =>
        getProjectsProjectId(projectId, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectId>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!projectId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Update project
 */
export const postProjectsProjectId = (
    projectId: string,
    project: Project,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(`/projects/${projectId}`, project, options)
}

export type PostProjectsProjectIdMutationResult = NonNullable<
    Awaited<ReturnType<typeof postProjectsProjectId>>
>
export type PostProjectsProjectIdMutationBody = Project
export type PostProjectsProjectIdMutationError = AxiosError<unknown>

export const usePostProjectsProjectId = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof postProjectsProjectId>>,
        TError,
        { projectId: string; data: Project },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof postProjectsProjectId>>,
        { projectId: string; data: Project }
    > = (props) => {
        const { projectId, data } = props ?? {}

        return postProjectsProjectId(projectId, data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof postProjectsProjectId>>,
        TError,
        { projectId: string; data: Project },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns the settings for a given project
 */
export const getProjectsProjectIdSettings = (
    projectId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsProjectIdSettings200>> => {
    return axios.get(`/projects/${projectId}/settings`, options)
}

export const getGetProjectsProjectIdSettingsQueryKey = (projectId: string) => [
    `/projects/${projectId}/settings`,
]

export type GetProjectsProjectIdSettingsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdSettings>>
>
export type GetProjectsProjectIdSettingsQueryError = AxiosError<unknown>

export const useGetProjectsProjectIdSettings = <
    TData = Awaited<ReturnType<typeof getProjectsProjectIdSettings>>,
    TError = AxiosError<unknown>
>(
    projectId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsProjectIdSettings>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdSettingsQueryKey(projectId)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdSettings>>
    > = ({ signal }) =>
        getProjectsProjectIdSettings(projectId, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdSettings>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!projectId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Updates the settings of a given project
 */
export const postProjectsProjectIdSettings = (
    projectId: string,
    projectSettings: ProjectSettings,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(
        `/projects/${projectId}/settings`,
        projectSettings,
        options
    )
}

export type PostProjectsProjectIdSettingsMutationResult = NonNullable<
    Awaited<ReturnType<typeof postProjectsProjectIdSettings>>
>
export type PostProjectsProjectIdSettingsMutationBody = ProjectSettings
export type PostProjectsProjectIdSettingsMutationError = AxiosError<unknown>

export const usePostProjectsProjectIdSettings = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof postProjectsProjectIdSettings>>,
        TError,
        { projectId: string; data: ProjectSettings },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof postProjectsProjectIdSettings>>,
        { projectId: string; data: ProjectSettings }
    > = (props) => {
        const { projectId, data } = props ?? {}

        return postProjectsProjectIdSettings(projectId, data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof postProjectsProjectIdSettings>>,
        TError,
        { projectId: string; data: ProjectSettings },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns code entries for given project
 */
export const getProjectsProjectIdCode = (
    projectId: string,
    params?: GetProjectsProjectIdCodeParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsProjectIdCode200>> => {
    return axios.get(`/projects/${projectId}/code`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsProjectIdCodeQueryKey = (
    projectId: string,
    params?: GetProjectsProjectIdCodeParams
) => [`/projects/${projectId}/code`, ...(params ? [params] : [])]

export type GetProjectsProjectIdCodeQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdCode>>
>
export type GetProjectsProjectIdCodeQueryError = AxiosError<unknown>

export const useGetProjectsProjectIdCode = <
    TData = Awaited<ReturnType<typeof getProjectsProjectIdCode>>,
    TError = AxiosError<unknown>
>(
    projectId: string,
    params?: GetProjectsProjectIdCodeParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsProjectIdCode>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdCodeQueryKey(projectId, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdCode>>
    > = ({ signal }) =>
        getProjectsProjectIdCode(projectId, params, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdCode>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!projectId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Add code repository
 */
export const putProjectsProjectIdCode = (
    projectId: string,
    codeRepository: CodeRepository,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<PutProjectsProjectIdCode201>> => {
    return axios.put(`/projects/${projectId}/code`, codeRepository, options)
}

export type PutProjectsProjectIdCodeMutationResult = NonNullable<
    Awaited<ReturnType<typeof putProjectsProjectIdCode>>
>
export type PutProjectsProjectIdCodeMutationBody = CodeRepository
export type PutProjectsProjectIdCodeMutationError = AxiosError<unknown>

export const usePutProjectsProjectIdCode = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof putProjectsProjectIdCode>>,
        TError,
        { projectId: string; data: CodeRepository },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof putProjectsProjectIdCode>>,
        { projectId: string; data: CodeRepository }
    > = (props) => {
        const { projectId, data } = props ?? {}

        return putProjectsProjectIdCode(projectId, data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof putProjectsProjectIdCode>>,
        TError,
        { projectId: string; data: CodeRepository },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns all codeRepos for given project and runs that the codeRepos were used in
 */
export const getProjectsProjectIdCodeUsage = (
    projectId: string,
    params?: GetProjectsProjectIdCodeUsageParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsProjectIdCodeUsage200>> => {
    return axios.get(`/projects/${projectId}/code/usage`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsProjectIdCodeUsageQueryKey = (
    projectId: string,
    params?: GetProjectsProjectIdCodeUsageParams
) => [`/projects/${projectId}/code/usage`, ...(params ? [params] : [])]

export type GetProjectsProjectIdCodeUsageQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdCodeUsage>>
>
export type GetProjectsProjectIdCodeUsageQueryError = AxiosError<unknown>

export const useGetProjectsProjectIdCodeUsage = <
    TData = Awaited<ReturnType<typeof getProjectsProjectIdCodeUsage>>,
    TError = AxiosError<unknown>
>(
    projectId: string,
    params?: GetProjectsProjectIdCodeUsageParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsProjectIdCodeUsage>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdCodeUsageQueryKey(projectId, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdCodeUsage>>
    > = ({ signal }) =>
        getProjectsProjectIdCodeUsage(projectId, params, {
            signal,
            ...axiosOptions,
        })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdCodeUsage>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!projectId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Returns code entry for given project
 */
export const getProjectsProjectIdCodeCodeRepositoryId = (
    projectId: string,
    codeRepositoryId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<CodeRepository>> => {
    return axios.get(`/projects/${projectId}/code/${codeRepositoryId}`, options)
}

export const getGetProjectsProjectIdCodeCodeRepositoryIdQueryKey = (
    projectId: string,
    codeRepositoryId: string
) => [`/projects/${projectId}/code/${codeRepositoryId}`]

export type GetProjectsProjectIdCodeCodeRepositoryIdQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdCodeCodeRepositoryId>>
>
export type GetProjectsProjectIdCodeCodeRepositoryIdQueryError =
    AxiosError<unknown>

export const useGetProjectsProjectIdCodeCodeRepositoryId = <
    TData = Awaited<
        ReturnType<typeof getProjectsProjectIdCodeCodeRepositoryId>
    >,
    TError = AxiosError<unknown>
>(
    projectId: string,
    codeRepositoryId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<
                ReturnType<typeof getProjectsProjectIdCodeCodeRepositoryId>
            >,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdCodeCodeRepositoryIdQueryKey(
            projectId,
            codeRepositoryId
        )

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdCodeCodeRepositoryId>>
    > = ({ signal }) =>
        getProjectsProjectIdCodeCodeRepositoryId(projectId, codeRepositoryId, {
            signal,
            ...axiosOptions,
        })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdCodeCodeRepositoryId>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!(projectId && codeRepositoryId),
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Updates code repository
 */
export const postProjectsProjectIdCodeCodeRepositoryId = (
    projectId: string,
    codeRepositoryId: string,
    codeRepository: CodeRepository,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(
        `/projects/${projectId}/code/${codeRepositoryId}`,
        codeRepository,
        options
    )
}

export type PostProjectsProjectIdCodeCodeRepositoryIdMutationResult =
    NonNullable<
        Awaited<ReturnType<typeof postProjectsProjectIdCodeCodeRepositoryId>>
    >
export type PostProjectsProjectIdCodeCodeRepositoryIdMutationBody =
    CodeRepository
export type PostProjectsProjectIdCodeCodeRepositoryIdMutationError =
    AxiosError<unknown>

export const usePostProjectsProjectIdCodeCodeRepositoryId = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof postProjectsProjectIdCodeCodeRepositoryId>>,
        TError,
        { projectId: string; codeRepositoryId: string; data: CodeRepository },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof postProjectsProjectIdCodeCodeRepositoryId>>,
        { projectId: string; codeRepositoryId: string; data: CodeRepository }
    > = (props) => {
        const { projectId, codeRepositoryId, data } = props ?? {}

        return postProjectsProjectIdCodeCodeRepositoryId(
            projectId,
            codeRepositoryId,
            data,
            axiosOptions
        )
    }

    return useMutation<
        Awaited<ReturnType<typeof postProjectsProjectIdCodeCodeRepositoryId>>,
        TError,
        { projectId: string; codeRepositoryId: string; data: CodeRepository },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns the settings for a specific code repository of a given project
 */
export const getProjectsProjectIdCodeCodeRepositoryIdSettings = (
    projectId: string,
    codeRepositoryId: string,
    options?: AxiosRequestConfig
): Promise<
    AxiosResponse<GetProjectsProjectIdCodeCodeRepositoryIdSettings200>
> => {
    return axios.get(
        `/projects/${projectId}/code/${codeRepositoryId}/settings`,
        options
    )
}

export const getGetProjectsProjectIdCodeCodeRepositoryIdSettingsQueryKey = (
    projectId: string,
    codeRepositoryId: string
) => [`/projects/${projectId}/code/${codeRepositoryId}/settings`]

export type GetProjectsProjectIdCodeCodeRepositoryIdSettingsQueryResult =
    NonNullable<
        Awaited<
            ReturnType<typeof getProjectsProjectIdCodeCodeRepositoryIdSettings>
        >
    >
export type GetProjectsProjectIdCodeCodeRepositoryIdSettingsQueryError =
    AxiosError<unknown>

export const useGetProjectsProjectIdCodeCodeRepositoryIdSettings = <
    TData = Awaited<
        ReturnType<typeof getProjectsProjectIdCodeCodeRepositoryIdSettings>
    >,
    TError = AxiosError<unknown>
>(
    projectId: string,
    codeRepositoryId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<
                ReturnType<
                    typeof getProjectsProjectIdCodeCodeRepositoryIdSettings
                >
            >,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdCodeCodeRepositoryIdSettingsQueryKey(
            projectId,
            codeRepositoryId
        )

    const queryFn: QueryFunction<
        Awaited<
            ReturnType<typeof getProjectsProjectIdCodeCodeRepositoryIdSettings>
        >
    > = ({ signal }) =>
        getProjectsProjectIdCodeCodeRepositoryIdSettings(
            projectId,
            codeRepositoryId,
            { signal, ...axiosOptions }
        )

    const query = useQuery<
        Awaited<
            ReturnType<typeof getProjectsProjectIdCodeCodeRepositoryIdSettings>
        >,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!(projectId && codeRepositoryId),
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Updates the settings for a specific code repository of a given project
 */
export const postProjectsProjectIdCodeCodeRepositoryIdSettings = (
    projectId: string,
    codeRepositoryId: string,
    codeRepositorySettings: CodeRepositorySettings,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(
        `/projects/${projectId}/code/${codeRepositoryId}/settings`,
        codeRepositorySettings,
        options
    )
}

export type PostProjectsProjectIdCodeCodeRepositoryIdSettingsMutationResult =
    NonNullable<
        Awaited<
            ReturnType<typeof postProjectsProjectIdCodeCodeRepositoryIdSettings>
        >
    >
export type PostProjectsProjectIdCodeCodeRepositoryIdSettingsMutationBody =
    CodeRepositorySettings
export type PostProjectsProjectIdCodeCodeRepositoryIdSettingsMutationError =
    AxiosError<unknown>

export const usePostProjectsProjectIdCodeCodeRepositoryIdSettings = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<
            ReturnType<typeof postProjectsProjectIdCodeCodeRepositoryIdSettings>
        >,
        TError,
        {
            projectId: string
            codeRepositoryId: string
            data: CodeRepositorySettings
        },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<
            ReturnType<typeof postProjectsProjectIdCodeCodeRepositoryIdSettings>
        >,
        {
            projectId: string
            codeRepositoryId: string
            data: CodeRepositorySettings
        }
    > = (props) => {
        const { projectId, codeRepositoryId, data } = props ?? {}

        return postProjectsProjectIdCodeCodeRepositoryIdSettings(
            projectId,
            codeRepositoryId,
            data,
            axiosOptions
        )
    }

    return useMutation<
        Awaited<
            ReturnType<typeof postProjectsProjectIdCodeCodeRepositoryIdSettings>
        >,
        TError,
        {
            projectId: string
            codeRepositoryId: string
            data: CodeRepositorySettings
        },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns data entries for given project
 */
export const getProjectsProjectIdData = (
    projectId: string,
    params?: GetProjectsProjectIdDataParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsProjectIdData200>> => {
    return axios.get(`/projects/${projectId}/data`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsProjectIdDataQueryKey = (
    projectId: string,
    params?: GetProjectsProjectIdDataParams
) => [`/projects/${projectId}/data`, ...(params ? [params] : [])]

export type GetProjectsProjectIdDataQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdData>>
>
export type GetProjectsProjectIdDataQueryError = AxiosError<unknown>

export const useGetProjectsProjectIdData = <
    TData = Awaited<ReturnType<typeof getProjectsProjectIdData>>,
    TError = AxiosError<unknown>
>(
    projectId: string,
    params?: GetProjectsProjectIdDataParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsProjectIdData>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdDataQueryKey(projectId, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdData>>
    > = ({ signal }) =>
        getProjectsProjectIdData(projectId, params, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdData>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!projectId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Add data repository
 */
export const putProjectsProjectIdData = (
    projectId: string,
    dataRepository: DataRepository,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<PutProjectsProjectIdData201>> => {
    return axios.put(`/projects/${projectId}/data`, dataRepository, options)
}

export type PutProjectsProjectIdDataMutationResult = NonNullable<
    Awaited<ReturnType<typeof putProjectsProjectIdData>>
>
export type PutProjectsProjectIdDataMutationBody = DataRepository
export type PutProjectsProjectIdDataMutationError = AxiosError<unknown>

export const usePutProjectsProjectIdData = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof putProjectsProjectIdData>>,
        TError,
        { projectId: string; data: DataRepository },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof putProjectsProjectIdData>>,
        { projectId: string; data: DataRepository }
    > = (props) => {
        const { projectId, data } = props ?? {}

        return putProjectsProjectIdData(projectId, data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof putProjectsProjectIdData>>,
        TError,
        { projectId: string; data: DataRepository },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns data entries for given project and runs grouped by the data
 */
export const getProjectsProjectIdDataUsage = (
    projectId: string,
    params?: GetProjectsProjectIdDataUsageParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsProjectIdDataUsage200>> => {
    return axios.get(`/projects/${projectId}/data/usage`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsProjectIdDataUsageQueryKey = (
    projectId: string,
    params?: GetProjectsProjectIdDataUsageParams
) => [`/projects/${projectId}/data/usage`, ...(params ? [params] : [])]

export type GetProjectsProjectIdDataUsageQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdDataUsage>>
>
export type GetProjectsProjectIdDataUsageQueryError = AxiosError<unknown>

export const useGetProjectsProjectIdDataUsage = <
    TData = Awaited<ReturnType<typeof getProjectsProjectIdDataUsage>>,
    TError = AxiosError<unknown>
>(
    projectId: string,
    params?: GetProjectsProjectIdDataUsageParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsProjectIdDataUsage>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdDataUsageQueryKey(projectId, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdDataUsage>>
    > = ({ signal }) =>
        getProjectsProjectIdDataUsage(projectId, params, {
            signal,
            ...axiosOptions,
        })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdDataUsage>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!projectId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Returns data entry for given project
 */
export const getProjectsProjectIdDataDataRepositoryId = (
    projectId: string,
    dataRepositoryId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<DataRepository>> => {
    return axios.get(`/projects/${projectId}/data/${dataRepositoryId}`, options)
}

export const getGetProjectsProjectIdDataDataRepositoryIdQueryKey = (
    projectId: string,
    dataRepositoryId: string
) => [`/projects/${projectId}/data/${dataRepositoryId}`]

export type GetProjectsProjectIdDataDataRepositoryIdQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdDataDataRepositoryId>>
>
export type GetProjectsProjectIdDataDataRepositoryIdQueryError =
    AxiosError<unknown>

export const useGetProjectsProjectIdDataDataRepositoryId = <
    TData = Awaited<
        ReturnType<typeof getProjectsProjectIdDataDataRepositoryId>
    >,
    TError = AxiosError<unknown>
>(
    projectId: string,
    dataRepositoryId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<
                ReturnType<typeof getProjectsProjectIdDataDataRepositoryId>
            >,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdDataDataRepositoryIdQueryKey(
            projectId,
            dataRepositoryId
        )

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdDataDataRepositoryId>>
    > = ({ signal }) =>
        getProjectsProjectIdDataDataRepositoryId(projectId, dataRepositoryId, {
            signal,
            ...axiosOptions,
        })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdDataDataRepositoryId>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!(projectId && dataRepositoryId),
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Update data repository
 */
export const postProjectsProjectIdDataDataRepositoryId = (
    projectId: string,
    dataRepositoryId: string,
    dataRepository: DataRepository,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(
        `/projects/${projectId}/data/${dataRepositoryId}`,
        dataRepository,
        options
    )
}

export type PostProjectsProjectIdDataDataRepositoryIdMutationResult =
    NonNullable<
        Awaited<ReturnType<typeof postProjectsProjectIdDataDataRepositoryId>>
    >
export type PostProjectsProjectIdDataDataRepositoryIdMutationBody =
    DataRepository
export type PostProjectsProjectIdDataDataRepositoryIdMutationError =
    AxiosError<unknown>

export const usePostProjectsProjectIdDataDataRepositoryId = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof postProjectsProjectIdDataDataRepositoryId>>,
        TError,
        { projectId: string; dataRepositoryId: string; data: DataRepository },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof postProjectsProjectIdDataDataRepositoryId>>,
        { projectId: string; dataRepositoryId: string; data: DataRepository }
    > = (props) => {
        const { projectId, dataRepositoryId, data } = props ?? {}

        return postProjectsProjectIdDataDataRepositoryId(
            projectId,
            dataRepositoryId,
            data,
            axiosOptions
        )
    }

    return useMutation<
        Awaited<ReturnType<typeof postProjectsProjectIdDataDataRepositoryId>>,
        TError,
        { projectId: string; dataRepositoryId: string; data: DataRepository },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns the settings for a specific data repository of a given project
 */
export const getProjectsProjectIdDataDataRepositoryIdSettings = (
    projectId: string,
    dataRepositoryId: string,
    options?: AxiosRequestConfig
): Promise<
    AxiosResponse<GetProjectsProjectIdDataDataRepositoryIdSettings200>
> => {
    return axios.get(
        `/projects/${projectId}/data/${dataRepositoryId}/settings`,
        options
    )
}

export const getGetProjectsProjectIdDataDataRepositoryIdSettingsQueryKey = (
    projectId: string,
    dataRepositoryId: string
) => [`/projects/${projectId}/data/${dataRepositoryId}/settings`]

export type GetProjectsProjectIdDataDataRepositoryIdSettingsQueryResult =
    NonNullable<
        Awaited<
            ReturnType<typeof getProjectsProjectIdDataDataRepositoryIdSettings>
        >
    >
export type GetProjectsProjectIdDataDataRepositoryIdSettingsQueryError =
    AxiosError<unknown>

export const useGetProjectsProjectIdDataDataRepositoryIdSettings = <
    TData = Awaited<
        ReturnType<typeof getProjectsProjectIdDataDataRepositoryIdSettings>
    >,
    TError = AxiosError<unknown>
>(
    projectId: string,
    dataRepositoryId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<
                ReturnType<
                    typeof getProjectsProjectIdDataDataRepositoryIdSettings
                >
            >,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdDataDataRepositoryIdSettingsQueryKey(
            projectId,
            dataRepositoryId
        )

    const queryFn: QueryFunction<
        Awaited<
            ReturnType<typeof getProjectsProjectIdDataDataRepositoryIdSettings>
        >
    > = ({ signal }) =>
        getProjectsProjectIdDataDataRepositoryIdSettings(
            projectId,
            dataRepositoryId,
            { signal, ...axiosOptions }
        )

    const query = useQuery<
        Awaited<
            ReturnType<typeof getProjectsProjectIdDataDataRepositoryIdSettings>
        >,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!(projectId && dataRepositoryId),
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Updates the settings for a specific data repository of a given project
 */
export const postProjectsProjectIdDataDataRepositoryIdSettings = (
    projectId: string,
    dataRepositoryId: string,
    dataRepositorySettings: DataRepositorySettings,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(
        `/projects/${projectId}/data/${dataRepositoryId}/settings`,
        dataRepositorySettings,
        options
    )
}

export type PostProjectsProjectIdDataDataRepositoryIdSettingsMutationResult =
    NonNullable<
        Awaited<
            ReturnType<typeof postProjectsProjectIdDataDataRepositoryIdSettings>
        >
    >
export type PostProjectsProjectIdDataDataRepositoryIdSettingsMutationBody =
    DataRepositorySettings
export type PostProjectsProjectIdDataDataRepositoryIdSettingsMutationError =
    AxiosError<unknown>

export const usePostProjectsProjectIdDataDataRepositoryIdSettings = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<
            ReturnType<typeof postProjectsProjectIdDataDataRepositoryIdSettings>
        >,
        TError,
        {
            projectId: string
            dataRepositoryId: string
            data: DataRepositorySettings
        },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<
            ReturnType<typeof postProjectsProjectIdDataDataRepositoryIdSettings>
        >,
        {
            projectId: string
            dataRepositoryId: string
            data: DataRepositorySettings
        }
    > = (props) => {
        const { projectId, dataRepositoryId, data } = props ?? {}

        return postProjectsProjectIdDataDataRepositoryIdSettings(
            projectId,
            dataRepositoryId,
            data,
            axiosOptions
        )
    }

    return useMutation<
        Awaited<
            ReturnType<typeof postProjectsProjectIdDataDataRepositoryIdSettings>
        >,
        TError,
        {
            projectId: string
            dataRepositoryId: string
            data: DataRepositorySettings
        },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns experiment entries for given project
 */
export const getProjectsProjectIdExperiments = (
    projectId: string,
    params?: GetProjectsProjectIdExperimentsParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsProjectIdExperiments200>> => {
    return axios.get(`/projects/${projectId}/experiments`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsProjectIdExperimentsQueryKey = (
    projectId: string,
    params?: GetProjectsProjectIdExperimentsParams
) => [`/projects/${projectId}/experiments`, ...(params ? [params] : [])]

export type GetProjectsProjectIdExperimentsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdExperiments>>
>
export type GetProjectsProjectIdExperimentsQueryError = AxiosError<unknown>

export const useGetProjectsProjectIdExperiments = <
    TData = Awaited<ReturnType<typeof getProjectsProjectIdExperiments>>,
    TError = AxiosError<unknown>
>(
    projectId: string,
    params?: GetProjectsProjectIdExperimentsParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsProjectIdExperiments>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdExperimentsQueryKey(projectId, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdExperiments>>
    > = ({ signal }) =>
        getProjectsProjectIdExperiments(projectId, params, {
            signal,
            ...axiosOptions,
        })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdExperiments>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!projectId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Add experiment repository
 */
export const putProjectsProjectIdExperiments = (
    projectId: string,
    experimentRepository: ExperimentRepository,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<PutProjectsProjectIdExperiments201>> => {
    return axios.put(
        `/projects/${projectId}/experiments`,
        experimentRepository,
        options
    )
}

export type PutProjectsProjectIdExperimentsMutationResult = NonNullable<
    Awaited<ReturnType<typeof putProjectsProjectIdExperiments>>
>
export type PutProjectsProjectIdExperimentsMutationBody = ExperimentRepository
export type PutProjectsProjectIdExperimentsMutationError = AxiosError<unknown>

export const usePutProjectsProjectIdExperiments = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof putProjectsProjectIdExperiments>>,
        TError,
        { projectId: string; data: ExperimentRepository },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof putProjectsProjectIdExperiments>>,
        { projectId: string; data: ExperimentRepository }
    > = (props) => {
        const { projectId, data } = props ?? {}

        return putProjectsProjectIdExperiments(projectId, data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof putProjectsProjectIdExperiments>>,
        TError,
        { projectId: string; data: ExperimentRepository },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns all experiments for given project and runs that the experiments were used in
 */
export const getProjectsProjectIdExperimentsUsage = (
    projectId: string,
    params?: GetProjectsProjectIdExperimentsUsageParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsProjectIdExperimentsUsage200>> => {
    return axios.get(`/projects/${projectId}/experiments/usage`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsProjectIdExperimentsUsageQueryKey = (
    projectId: string,
    params?: GetProjectsProjectIdExperimentsUsageParams
) => [`/projects/${projectId}/experiments/usage`, ...(params ? [params] : [])]

export type GetProjectsProjectIdExperimentsUsageQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdExperimentsUsage>>
>
export type GetProjectsProjectIdExperimentsUsageQueryError = AxiosError<unknown>

export const useGetProjectsProjectIdExperimentsUsage = <
    TData = Awaited<ReturnType<typeof getProjectsProjectIdExperimentsUsage>>,
    TError = AxiosError<unknown>
>(
    projectId: string,
    params?: GetProjectsProjectIdExperimentsUsageParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsProjectIdExperimentsUsage>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdExperimentsUsageQueryKey(projectId, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdExperimentsUsage>>
    > = ({ signal }) =>
        getProjectsProjectIdExperimentsUsage(projectId, params, {
            signal,
            ...axiosOptions,
        })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdExperimentsUsage>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!projectId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Returns experiment entry for given project
 */
export const getProjectsProjectIdExperimentsExperimentRepositoryId = (
    projectId: string,
    experimentRepositoryId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<ExperimentRepository>> => {
    return axios.get(
        `/projects/${projectId}/experiments/${experimentRepositoryId}`,
        options
    )
}

export const getGetProjectsProjectIdExperimentsExperimentRepositoryIdQueryKey =
    (projectId: string, experimentRepositoryId: string) => [
        `/projects/${projectId}/experiments/${experimentRepositoryId}`,
    ]

export type GetProjectsProjectIdExperimentsExperimentRepositoryIdQueryResult =
    NonNullable<
        Awaited<
            ReturnType<
                typeof getProjectsProjectIdExperimentsExperimentRepositoryId
            >
        >
    >
export type GetProjectsProjectIdExperimentsExperimentRepositoryIdQueryError =
    AxiosError<unknown>

export const useGetProjectsProjectIdExperimentsExperimentRepositoryId = <
    TData = Awaited<
        ReturnType<typeof getProjectsProjectIdExperimentsExperimentRepositoryId>
    >,
    TError = AxiosError<unknown>
>(
    projectId: string,
    experimentRepositoryId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<
                ReturnType<
                    typeof getProjectsProjectIdExperimentsExperimentRepositoryId
                >
            >,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdExperimentsExperimentRepositoryIdQueryKey(
            projectId,
            experimentRepositoryId
        )

    const queryFn: QueryFunction<
        Awaited<
            ReturnType<
                typeof getProjectsProjectIdExperimentsExperimentRepositoryId
            >
        >
    > = ({ signal }) =>
        getProjectsProjectIdExperimentsExperimentRepositoryId(
            projectId,
            experimentRepositoryId,
            { signal, ...axiosOptions }
        )

    const query = useQuery<
        Awaited<
            ReturnType<
                typeof getProjectsProjectIdExperimentsExperimentRepositoryId
            >
        >,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!(projectId && experimentRepositoryId),
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Update experiment repository
 */
export const postProjectsProjectIdExperimentsExperimentRepositoryId = (
    projectId: string,
    experimentRepositoryId: string,
    experimentRepository: ExperimentRepository,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(
        `/projects/${projectId}/experiments/${experimentRepositoryId}`,
        experimentRepository,
        options
    )
}

export type PostProjectsProjectIdExperimentsExperimentRepositoryIdMutationResult =
    NonNullable<
        Awaited<
            ReturnType<
                typeof postProjectsProjectIdExperimentsExperimentRepositoryId
            >
        >
    >
export type PostProjectsProjectIdExperimentsExperimentRepositoryIdMutationBody =
    ExperimentRepository
export type PostProjectsProjectIdExperimentsExperimentRepositoryIdMutationError =
    AxiosError<unknown>

export const usePostProjectsProjectIdExperimentsExperimentRepositoryId = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<
            ReturnType<
                typeof postProjectsProjectIdExperimentsExperimentRepositoryId
            >
        >,
        TError,
        {
            projectId: string
            experimentRepositoryId: string
            data: ExperimentRepository
        },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<
            ReturnType<
                typeof postProjectsProjectIdExperimentsExperimentRepositoryId
            >
        >,
        {
            projectId: string
            experimentRepositoryId: string
            data: ExperimentRepository
        }
    > = (props) => {
        const { projectId, experimentRepositoryId, data } = props ?? {}

        return postProjectsProjectIdExperimentsExperimentRepositoryId(
            projectId,
            experimentRepositoryId,
            data,
            axiosOptions
        )
    }

    return useMutation<
        Awaited<
            ReturnType<
                typeof postProjectsProjectIdExperimentsExperimentRepositoryId
            >
        >,
        TError,
        {
            projectId: string
            experimentRepositoryId: string
            data: ExperimentRepository
        },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns model entries for given project
 */
export const getProjectsProjectIdModels = (
    projectId: string,
    params?: GetProjectsProjectIdModelsParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsProjectIdModels200>> => {
    return axios.get(`/projects/${projectId}/models`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsProjectIdModelsQueryKey = (
    projectId: string,
    params?: GetProjectsProjectIdModelsParams
) => [`/projects/${projectId}/models`, ...(params ? [params] : [])]

export type GetProjectsProjectIdModelsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdModels>>
>
export type GetProjectsProjectIdModelsQueryError = AxiosError<unknown>

export const useGetProjectsProjectIdModels = <
    TData = Awaited<ReturnType<typeof getProjectsProjectIdModels>>,
    TError = AxiosError<unknown>
>(
    projectId: string,
    params?: GetProjectsProjectIdModelsParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsProjectIdModels>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdModelsQueryKey(projectId, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdModels>>
    > = ({ signal }) =>
        getProjectsProjectIdModels(projectId, params, {
            signal,
            ...axiosOptions,
        })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdModels>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!projectId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Add model repository
 */
export const putProjectsProjectIdModels = (
    projectId: string,
    modelRepository: ModelRepository[],
    options?: AxiosRequestConfig
): Promise<AxiosResponse<PutProjectsProjectIdModels201>> => {
    return axios.put(`/projects/${projectId}/models`, modelRepository, options)
}

export type PutProjectsProjectIdModelsMutationResult = NonNullable<
    Awaited<ReturnType<typeof putProjectsProjectIdModels>>
>
export type PutProjectsProjectIdModelsMutationBody = ModelRepository[]
export type PutProjectsProjectIdModelsMutationError = AxiosError<unknown>

export const usePutProjectsProjectIdModels = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof putProjectsProjectIdModels>>,
        TError,
        { projectId: string; data: ModelRepository[] },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof putProjectsProjectIdModels>>,
        { projectId: string; data: ModelRepository[] }
    > = (props) => {
        const { projectId, data } = props ?? {}

        return putProjectsProjectIdModels(projectId, data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof putProjectsProjectIdModels>>,
        TError,
        { projectId: string; data: ModelRepository[] },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns all models for given project and runs that the models were created in
 */
export const getProjectsProjectIdModelsUsage = (
    projectId: string,
    params?: GetProjectsProjectIdModelsUsageParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsProjectIdModelsUsage200>> => {
    return axios.get(`/projects/${projectId}/models/usage`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsProjectIdModelsUsageQueryKey = (
    projectId: string,
    params?: GetProjectsProjectIdModelsUsageParams
) => [`/projects/${projectId}/models/usage`, ...(params ? [params] : [])]

export type GetProjectsProjectIdModelsUsageQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdModelsUsage>>
>
export type GetProjectsProjectIdModelsUsageQueryError = AxiosError<unknown>

export const useGetProjectsProjectIdModelsUsage = <
    TData = Awaited<ReturnType<typeof getProjectsProjectIdModelsUsage>>,
    TError = AxiosError<unknown>
>(
    projectId: string,
    params?: GetProjectsProjectIdModelsUsageParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsProjectIdModelsUsage>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdModelsUsageQueryKey(projectId, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdModelsUsage>>
    > = ({ signal }) =>
        getProjectsProjectIdModelsUsage(projectId, params, {
            signal,
            ...axiosOptions,
        })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdModelsUsage>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!projectId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Returns model entry for given ID
 */
export const getProjectsProjectIdModelsModelRepositoryId = (
    projectId: string,
    modelRepositoryId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<ModelRepository>> => {
    return axios.get(
        `/projects/${projectId}/models/${modelRepositoryId}`,
        options
    )
}

export const getGetProjectsProjectIdModelsModelRepositoryIdQueryKey = (
    projectId: string,
    modelRepositoryId: string
) => [`/projects/${projectId}/models/${modelRepositoryId}`]

export type GetProjectsProjectIdModelsModelRepositoryIdQueryResult =
    NonNullable<
        Awaited<ReturnType<typeof getProjectsProjectIdModelsModelRepositoryId>>
    >
export type GetProjectsProjectIdModelsModelRepositoryIdQueryError =
    AxiosError<unknown>

export const useGetProjectsProjectIdModelsModelRepositoryId = <
    TData = Awaited<
        ReturnType<typeof getProjectsProjectIdModelsModelRepositoryId>
    >,
    TError = AxiosError<unknown>
>(
    projectId: string,
    modelRepositoryId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<
                ReturnType<typeof getProjectsProjectIdModelsModelRepositoryId>
            >,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdModelsModelRepositoryIdQueryKey(
            projectId,
            modelRepositoryId
        )

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdModelsModelRepositoryId>>
    > = ({ signal }) =>
        getProjectsProjectIdModelsModelRepositoryId(
            projectId,
            modelRepositoryId,
            { signal, ...axiosOptions }
        )

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdModelsModelRepositoryId>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!(projectId && modelRepositoryId),
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Update model repository
 */
export const postProjectsProjectIdModelsModelRepositoryId = (
    projectId: string,
    modelRepositoryId: string,
    modelRepository: ModelRepository,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(
        `/projects/${projectId}/models/${modelRepositoryId}`,
        modelRepository,
        options
    )
}

export type PostProjectsProjectIdModelsModelRepositoryIdMutationResult =
    NonNullable<
        Awaited<ReturnType<typeof postProjectsProjectIdModelsModelRepositoryId>>
    >
export type PostProjectsProjectIdModelsModelRepositoryIdMutationBody =
    ModelRepository
export type PostProjectsProjectIdModelsModelRepositoryIdMutationError =
    AxiosError<unknown>

export const usePostProjectsProjectIdModelsModelRepositoryId = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<
            ReturnType<typeof postProjectsProjectIdModelsModelRepositoryId>
        >,
        TError,
        { projectId: string; modelRepositoryId: string; data: ModelRepository },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<
            ReturnType<typeof postProjectsProjectIdModelsModelRepositoryId>
        >,
        { projectId: string; modelRepositoryId: string; data: ModelRepository }
    > = (props) => {
        const { projectId, modelRepositoryId, data } = props ?? {}

        return postProjectsProjectIdModelsModelRepositoryId(
            projectId,
            modelRepositoryId,
            data,
            axiosOptions
        )
    }

    return useMutation<
        Awaited<
            ReturnType<typeof postProjectsProjectIdModelsModelRepositoryId>
        >,
        TError,
        { projectId: string; modelRepositoryId: string; data: ModelRepository },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Returns all runs for a given project
 */
export const getProjectsProjectIdRuns = (
    projectId: string,
    params?: GetProjectsProjectIdRunsParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsProjectIdRuns200>> => {
    return axios.get(`/projects/${projectId}/runs`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsProjectIdRunsQueryKey = (
    projectId: string,
    params?: GetProjectsProjectIdRunsParams
) => [`/projects/${projectId}/runs`, ...(params ? [params] : [])]

export type GetProjectsProjectIdRunsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdRuns>>
>
export type GetProjectsProjectIdRunsQueryError = AxiosError<unknown>

export const useGetProjectsProjectIdRuns = <
    TData = Awaited<ReturnType<typeof getProjectsProjectIdRuns>>,
    TError = AxiosError<unknown>
>(
    projectId: string,
    params?: GetProjectsProjectIdRunsParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsProjectIdRuns>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdRunsQueryKey(projectId, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdRuns>>
    > = ({ signal }) =>
        getProjectsProjectIdRuns(projectId, params, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdRuns>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!projectId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Creates a new run
 */
export const putProjectsProjectIdRuns = (
    projectId: string,
    addRun: AddRun,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<PutProjectsProjectIdRuns201>> => {
    return axios.put(`/projects/${projectId}/runs`, addRun, options)
}

export type PutProjectsProjectIdRunsMutationResult = NonNullable<
    Awaited<ReturnType<typeof putProjectsProjectIdRuns>>
>
export type PutProjectsProjectIdRunsMutationBody = AddRun
export type PutProjectsProjectIdRunsMutationError = AxiosError<unknown>

export const usePutProjectsProjectIdRuns = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof putProjectsProjectIdRuns>>,
        TError,
        { projectId: string; data: AddRun },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof putProjectsProjectIdRuns>>,
        { projectId: string; data: AddRun }
    > = (props) => {
        const { projectId, data } = props ?? {}

        return putProjectsProjectIdRuns(projectId, data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof putProjectsProjectIdRuns>>,
        TError,
        { projectId: string; data: AddRun },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Return a curation of projects tailored for a specific user with a set of search parameters
 */
export const getProjectsUserUserIdSearch = (
    userId: string,
    params?: GetProjectsUserUserIdSearchParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsUserUserIdSearch200>> => {
    return axios.get(`/projects/user/${userId}/search`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsUserUserIdSearchQueryKey = (
    userId: string,
    params?: GetProjectsUserUserIdSearchParams
) => [`/projects/user/${userId}/search`, ...(params ? [params] : [])]

export type GetProjectsUserUserIdSearchQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsUserUserIdSearch>>
>
export type GetProjectsUserUserIdSearchQueryError = AxiosError<unknown>

export const useGetProjectsUserUserIdSearch = <
    TData = Awaited<ReturnType<typeof getProjectsUserUserIdSearch>>,
    TError = AxiosError<unknown>
>(
    userId: string,
    params?: GetProjectsUserUserIdSearchParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsUserUserIdSearch>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsUserUserIdSearchQueryKey(userId, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsUserUserIdSearch>>
    > = ({ signal }) =>
        getProjectsUserUserIdSearch(userId, params, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsUserUserIdSearch>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!userId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary List all deployments
 */
export const getProjectsProjectIdDeployments = (
    projectId: string,
    params?: GetProjectsProjectIdDeploymentsParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetProjectsProjectIdDeployments200>> => {
    return axios.get(`/projects/${projectId}/deployments`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetProjectsProjectIdDeploymentsQueryKey = (
    projectId: string,
    params?: GetProjectsProjectIdDeploymentsParams
) => [`/projects/${projectId}/deployments`, ...(params ? [params] : [])]

export type GetProjectsProjectIdDeploymentsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getProjectsProjectIdDeployments>>
>
export type GetProjectsProjectIdDeploymentsQueryError = AxiosError<unknown>

export const useGetProjectsProjectIdDeployments = <
    TData = Awaited<ReturnType<typeof getProjectsProjectIdDeployments>>,
    TError = AxiosError<unknown>
>(
    projectId: string,
    params?: GetProjectsProjectIdDeploymentsParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getProjectsProjectIdDeployments>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdDeploymentsQueryKey(projectId, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdDeployments>>
    > = ({ signal }) =>
        getProjectsProjectIdDeployments(projectId, params, {
            signal,
            ...axiosOptions,
        })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdDeployments>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!projectId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Create deployment
 */
export const putProjectsProjectIdDeployments = (
    projectId: string,
    deploymentInformation: DeploymentInformation,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<PutProjectsProjectIdDeployments201>> => {
    return axios.put(
        `/projects/${projectId}/deployments`,
        deploymentInformation,
        options
    )
}

export type PutProjectsProjectIdDeploymentsMutationResult = NonNullable<
    Awaited<ReturnType<typeof putProjectsProjectIdDeployments>>
>
export type PutProjectsProjectIdDeploymentsMutationBody = DeploymentInformation
export type PutProjectsProjectIdDeploymentsMutationError = AxiosError<unknown>

export const usePutProjectsProjectIdDeployments = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof putProjectsProjectIdDeployments>>,
        TError,
        { projectId: string; data: DeploymentInformation },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof putProjectsProjectIdDeployments>>,
        { projectId: string; data: DeploymentInformation }
    > = (props) => {
        const { projectId, data } = props ?? {}

        return putProjectsProjectIdDeployments(projectId, data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof putProjectsProjectIdDeployments>>,
        TError,
        { projectId: string; data: DeploymentInformation },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Get deployment information
 */
export const getProjectsProjectIdDeploymentsDeploymentId = (
    projectId: string,
    deploymentId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<DeploymentInformation>> => {
    return axios.get(
        `/projects/${projectId}/deployments/${deploymentId}`,
        options
    )
}

export const getGetProjectsProjectIdDeploymentsDeploymentIdQueryKey = (
    projectId: string,
    deploymentId: string
) => [`/projects/${projectId}/deployments/${deploymentId}`]

export type GetProjectsProjectIdDeploymentsDeploymentIdQueryResult =
    NonNullable<
        Awaited<ReturnType<typeof getProjectsProjectIdDeploymentsDeploymentId>>
    >
export type GetProjectsProjectIdDeploymentsDeploymentIdQueryError =
    AxiosError<unknown>

export const useGetProjectsProjectIdDeploymentsDeploymentId = <
    TData = Awaited<
        ReturnType<typeof getProjectsProjectIdDeploymentsDeploymentId>
    >,
    TError = AxiosError<unknown>
>(
    projectId: string,
    deploymentId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<
                ReturnType<typeof getProjectsProjectIdDeploymentsDeploymentId>
            >,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdDeploymentsDeploymentIdQueryKey(
            projectId,
            deploymentId
        )

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getProjectsProjectIdDeploymentsDeploymentId>>
    > = ({ signal }) =>
        getProjectsProjectIdDeploymentsDeploymentId(projectId, deploymentId, {
            signal,
            ...axiosOptions,
        })

    const query = useQuery<
        Awaited<ReturnType<typeof getProjectsProjectIdDeploymentsDeploymentId>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!(projectId && deploymentId),
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Update deployment
 */
export const postProjectsProjectIdDeploymentsDeploymentId = (
    projectId: string,
    deploymentId: string,
    deploymentInformation: DeploymentInformation,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(
        `/projects/${projectId}/deployments/${deploymentId}`,
        deploymentInformation,
        options
    )
}

export type PostProjectsProjectIdDeploymentsDeploymentIdMutationResult =
    NonNullable<
        Awaited<ReturnType<typeof postProjectsProjectIdDeploymentsDeploymentId>>
    >
export type PostProjectsProjectIdDeploymentsDeploymentIdMutationBody =
    DeploymentInformation
export type PostProjectsProjectIdDeploymentsDeploymentIdMutationError =
    AxiosError<unknown>

export const usePostProjectsProjectIdDeploymentsDeploymentId = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<
            ReturnType<typeof postProjectsProjectIdDeploymentsDeploymentId>
        >,
        TError,
        {
            projectId: string
            deploymentId: string
            data: DeploymentInformation
        },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<
            ReturnType<typeof postProjectsProjectIdDeploymentsDeploymentId>
        >,
        { projectId: string; deploymentId: string; data: DeploymentInformation }
    > = (props) => {
        const { projectId, deploymentId, data } = props ?? {}

        return postProjectsProjectIdDeploymentsDeploymentId(
            projectId,
            deploymentId,
            data,
            axiosOptions
        )
    }

    return useMutation<
        Awaited<
            ReturnType<typeof postProjectsProjectIdDeploymentsDeploymentId>
        >,
        TError,
        {
            projectId: string
            deploymentId: string
            data: DeploymentInformation
        },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Delete deployment
 */
export const deleteProjectsProjectIdDeploymentsDeploymentId = (
    projectId: string,
    deploymentId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.delete(
        `/projects/${projectId}/deployments/${deploymentId}`,
        options
    )
}

export type DeleteProjectsProjectIdDeploymentsDeploymentIdMutationResult =
    NonNullable<
        Awaited<
            ReturnType<typeof deleteProjectsProjectIdDeploymentsDeploymentId>
        >
    >

export type DeleteProjectsProjectIdDeploymentsDeploymentIdMutationError =
    AxiosError<unknown>

export const useDeleteProjectsProjectIdDeploymentsDeploymentId = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<
            ReturnType<typeof deleteProjectsProjectIdDeploymentsDeploymentId>
        >,
        TError,
        { projectId: string; deploymentId: string },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<
            ReturnType<typeof deleteProjectsProjectIdDeploymentsDeploymentId>
        >,
        { projectId: string; deploymentId: string }
    > = (props) => {
        const { projectId, deploymentId } = props ?? {}

        return deleteProjectsProjectIdDeploymentsDeploymentId(
            projectId,
            deploymentId,
            axiosOptions
        )
    }

    return useMutation<
        Awaited<
            ReturnType<typeof deleteProjectsProjectIdDeploymentsDeploymentId>
        >,
        TError,
        { projectId: string; deploymentId: string },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Download packaged deployment
 */
export const getProjectsProjectIdDeploymentsDeploymentIdDownload = (
    projectId: string,
    deploymentId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<PackagedDeployment>> => {
    return axios.get(
        `/projects/${projectId}/deployments/${deploymentId}/download`,
        options
    )
}

export const getGetProjectsProjectIdDeploymentsDeploymentIdDownloadQueryKey = (
    projectId: string,
    deploymentId: string
) => [`/projects/${projectId}/deployments/${deploymentId}/download`]

export type GetProjectsProjectIdDeploymentsDeploymentIdDownloadQueryResult =
    NonNullable<
        Awaited<
            ReturnType<
                typeof getProjectsProjectIdDeploymentsDeploymentIdDownload
            >
        >
    >
export type GetProjectsProjectIdDeploymentsDeploymentIdDownloadQueryError =
    AxiosError<unknown>

export const useGetProjectsProjectIdDeploymentsDeploymentIdDownload = <
    TData = Awaited<
        ReturnType<typeof getProjectsProjectIdDeploymentsDeploymentIdDownload>
    >,
    TError = AxiosError<unknown>
>(
    projectId: string,
    deploymentId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<
                ReturnType<
                    typeof getProjectsProjectIdDeploymentsDeploymentIdDownload
                >
            >,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdDeploymentsDeploymentIdDownloadQueryKey(
            projectId,
            deploymentId
        )

    const queryFn: QueryFunction<
        Awaited<
            ReturnType<
                typeof getProjectsProjectIdDeploymentsDeploymentIdDownload
            >
        >
    > = ({ signal }) =>
        getProjectsProjectIdDeploymentsDeploymentIdDownload(
            projectId,
            deploymentId,
            { signal, ...axiosOptions }
        )

    const query = useQuery<
        Awaited<
            ReturnType<
                typeof getProjectsProjectIdDeploymentsDeploymentIdDownload
            >
        >,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!(projectId && deploymentId),
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Get deployment information
 */
export const getProjectsProjectIdDeploymentsDeploymentIdPredict = (
    projectId: string,
    deploymentId: string,
    predictionRequest: PredictionRequest,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<PredictionResponse>> => {
    return axios.get(
        `/projects/${projectId}/deployments/${deploymentId}/predict`,
        options
    )
}

export const getGetProjectsProjectIdDeploymentsDeploymentIdPredictQueryKey = (
    projectId: string,
    deploymentId: string,
    predictionRequest: PredictionRequest
) => [
    `/projects/${projectId}/deployments/${deploymentId}/predict`,
    predictionRequest,
]

export type GetProjectsProjectIdDeploymentsDeploymentIdPredictQueryResult =
    NonNullable<
        Awaited<
            ReturnType<
                typeof getProjectsProjectIdDeploymentsDeploymentIdPredict
            >
        >
    >
export type GetProjectsProjectIdDeploymentsDeploymentIdPredictQueryError =
    AxiosError<unknown>

export const useGetProjectsProjectIdDeploymentsDeploymentIdPredict = <
    TData = Awaited<
        ReturnType<typeof getProjectsProjectIdDeploymentsDeploymentIdPredict>
    >,
    TError = AxiosError<unknown>
>(
    projectId: string,
    deploymentId: string,
    predictionRequest: PredictionRequest,
    options?: {
        query?: UseQueryOptions<
            Awaited<
                ReturnType<
                    typeof getProjectsProjectIdDeploymentsDeploymentIdPredict
                >
            >,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetProjectsProjectIdDeploymentsDeploymentIdPredictQueryKey(
            projectId,
            deploymentId,
            predictionRequest
        )

    const queryFn: QueryFunction<
        Awaited<
            ReturnType<
                typeof getProjectsProjectIdDeploymentsDeploymentIdPredict
            >
        >
    > = ({ signal }) =>
        getProjectsProjectIdDeploymentsDeploymentIdPredict(
            projectId,
            deploymentId,
            predictionRequest,
            { signal, ...axiosOptions }
        )

    const query = useQuery<
        Awaited<
            ReturnType<
                typeof getProjectsProjectIdDeploymentsDeploymentIdPredict
            >
        >,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!(projectId && deploymentId),
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Get all User group (admin only)
 */
export const getGroups = (
    params?: GetGroupsParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetGroups200>> => {
    return axios.get(`/groups`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetGroupsQueryKey = (params?: GetGroupsParams) => [
    `/groups`,
    ...(params ? [params] : []),
]

export type GetGroupsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getGroups>>
>
export type GetGroupsQueryError = AxiosError<unknown>

export const useGetGroups = <
    TData = Awaited<ReturnType<typeof getGroups>>,
    TError = AxiosError<unknown>
>(
    params?: GetGroupsParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getGroups>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetGroupsQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroups>>> = ({
        signal,
    }) => getGroups(params, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getGroups>>,
        TError,
        TData
    >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
        queryKey: QueryKey
    }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Create a new user group
 */
export const putGroups = (
    userGroup: UserGroup,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<PutGroups201>> => {
    return axios.put(`/groups`, userGroup, options)
}

export type PutGroupsMutationResult = NonNullable<
    Awaited<ReturnType<typeof putGroups>>
>
export type PutGroupsMutationBody = UserGroup
export type PutGroupsMutationError = AxiosError<unknown>

export const usePutGroups = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof putGroups>>,
        TError,
        { data: UserGroup },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof putGroups>>,
        { data: UserGroup }
    > = (props) => {
        const { data } = props ?? {}

        return putGroups(data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof putGroups>>,
        TError,
        { data: UserGroup },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Get Group information
 */
export const getGroupsGroupId = (
    groupId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<UserGroup>> => {
    return axios.get(`/groups/${groupId}`, options)
}

export const getGetGroupsGroupIdQueryKey = (groupId: string) => [
    `/groups/${groupId}`,
]

export type GetGroupsGroupIdQueryResult = NonNullable<
    Awaited<ReturnType<typeof getGroupsGroupId>>
>
export type GetGroupsGroupIdQueryError = AxiosError<unknown>

export const useGetGroupsGroupId = <
    TData = Awaited<ReturnType<typeof getGroupsGroupId>>,
    TError = AxiosError<unknown>
>(
    groupId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getGroupsGroupId>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ?? getGetGroupsGroupIdQueryKey(groupId)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getGroupsGroupId>>
    > = ({ signal }) => getGroupsGroupId(groupId, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getGroupsGroupId>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!groupId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Update group
 */
export const postGroupsGroupId = (
    groupId: string,
    userGroup: UserGroup,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(`/groups/${groupId}`, userGroup, options)
}

export type PostGroupsGroupIdMutationResult = NonNullable<
    Awaited<ReturnType<typeof postGroupsGroupId>>
>
export type PostGroupsGroupIdMutationBody = UserGroup
export type PostGroupsGroupIdMutationError = AxiosError<unknown>

export const usePostGroupsGroupId = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof postGroupsGroupId>>,
        TError,
        { groupId: string; data: UserGroup },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof postGroupsGroupId>>,
        { groupId: string; data: UserGroup }
    > = (props) => {
        const { groupId, data } = props ?? {}

        return postGroupsGroupId(groupId, data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof postGroupsGroupId>>,
        TError,
        { groupId: string; data: UserGroup },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Get list of organizations (admin only)
 */
export const getOrganizations = (
    params?: GetOrganizationsParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetOrganizations200>> => {
    return axios.get(`/organizations`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetOrganizationsQueryKey = (
    params?: GetOrganizationsParams
) => [`/organizations`, ...(params ? [params] : [])]

export type GetOrganizationsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getOrganizations>>
>
export type GetOrganizationsQueryError = AxiosError<unknown>

export const useGetOrganizations = <
    TData = Awaited<ReturnType<typeof getOrganizations>>,
    TError = AxiosError<unknown>
>(
    params?: GetOrganizationsParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getOrganizations>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ?? getGetOrganizationsQueryKey(params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getOrganizations>>
    > = ({ signal }) => getOrganizations(params, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getOrganizations>>,
        TError,
        TData
    >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
        queryKey: QueryKey
    }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Add organization
 */
export const putOrganizations = (
    organization: Organization,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<PutOrganizations201>> => {
    return axios.put(`/organizations`, organization, options)
}

export type PutOrganizationsMutationResult = NonNullable<
    Awaited<ReturnType<typeof putOrganizations>>
>
export type PutOrganizationsMutationBody = Organization
export type PutOrganizationsMutationError = AxiosError<unknown>

export const usePutOrganizations = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof putOrganizations>>,
        TError,
        { data: Organization },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof putOrganizations>>,
        { data: Organization }
    > = (props) => {
        const { data } = props ?? {}

        return putOrganizations(data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof putOrganizations>>,
        TError,
        { data: Organization },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Get info on specified organization
 */
export const getOrganizationsOrganizationId = (
    organizationId: string,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<Organization>> => {
    return axios.get(`/organizations/${organizationId}`, options)
}

export const getGetOrganizationsOrganizationIdQueryKey = (
    organizationId: string
) => [`/organizations/${organizationId}`]

export type GetOrganizationsOrganizationIdQueryResult = NonNullable<
    Awaited<ReturnType<typeof getOrganizationsOrganizationId>>
>
export type GetOrganizationsOrganizationIdQueryError = AxiosError<unknown>

export const useGetOrganizationsOrganizationId = <
    TData = Awaited<ReturnType<typeof getOrganizationsOrganizationId>>,
    TError = AxiosError<unknown>
>(
    organizationId: string,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getOrganizationsOrganizationId>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ??
        getGetOrganizationsOrganizationIdQueryKey(organizationId)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getOrganizationsOrganizationId>>
    > = ({ signal }) =>
        getOrganizationsOrganizationId(organizationId, {
            signal,
            ...axiosOptions,
        })

    const query = useQuery<
        Awaited<ReturnType<typeof getOrganizationsOrganizationId>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!organizationId,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Update organization info
 */
export const postOrganizationsOrganizationId = (
    organizationId: string,
    organization: Organization,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
    return axios.post(`/organizations/${organizationId}`, organization, options)
}

export type PostOrganizationsOrganizationIdMutationResult = NonNullable<
    Awaited<ReturnType<typeof postOrganizationsOrganizationId>>
>
export type PostOrganizationsOrganizationIdMutationBody = Organization
export type PostOrganizationsOrganizationIdMutationError = AxiosError<unknown>

export const usePostOrganizationsOrganizationId = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof postOrganizationsOrganizationId>>,
        TError,
        { organizationId: string; data: Organization },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof postOrganizationsOrganizationId>>,
        { organizationId: string; data: Organization }
    > = (props) => {
        const { organizationId, data } = props ?? {}

        return postOrganizationsOrganizationId(
            organizationId,
            data,
            axiosOptions
        )
    }

    return useMutation<
        Awaited<ReturnType<typeof postOrganizationsOrganizationId>>,
        TError,
        { organizationId: string; data: Organization },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Get all labels (admin only)
 */
export const getLabels = (
    params?: GetLabelsParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetLabels200>> => {
    return axios.get(`/labels`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetLabelsQueryKey = (params?: GetLabelsParams) => [
    `/labels`,
    ...(params ? [params] : []),
]

export type GetLabelsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getLabels>>
>
export type GetLabelsQueryError = AxiosError<unknown>

export const useGetLabels = <
    TData = Awaited<ReturnType<typeof getLabels>>,
    TError = AxiosError<unknown>
>(
    params?: GetLabelsParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getLabels>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetLabelsQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLabels>>> = ({
        signal,
    }) => getLabels(params, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getLabels>>,
        TError,
        TData
    >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
        queryKey: QueryKey
    }

    query.queryKey = queryKey

    return query
}

/**
 * @summary add label
 */
export const putLabels = (
    label: Label,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<Label>> => {
    return axios.put(`/labels`, label, options)
}

export type PutLabelsMutationResult = NonNullable<
    Awaited<ReturnType<typeof putLabels>>
>
export type PutLabelsMutationBody = Label
export type PutLabelsMutationError = AxiosError<unknown>

export const usePutLabels = <
    TError = AxiosError<unknown>,
    TContext = unknown
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof putLabels>>,
        TError,
        { data: Label },
        TContext
    >
    axios?: AxiosRequestConfig
}) => {
    const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof putLabels>>,
        { data: Label }
    > = (props) => {
        const { data } = props ?? {}

        return putLabels(data, axiosOptions)
    }

    return useMutation<
        Awaited<ReturnType<typeof putLabels>>,
        TError,
        { data: Label },
        TContext
    >(mutationFn, mutationOptions)
}
/**
 * @summary Return all labels of the given scope
 */
export const getLabelsScope = (
    scope: string,
    params?: GetLabelsScopeParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetLabelsScope200>> => {
    return axios.get(`/labels/${scope}`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetLabelsScopeQueryKey = (
    scope: string,
    params?: GetLabelsScopeParams
) => [`/labels/${scope}`, ...(params ? [params] : [])]

export type GetLabelsScopeQueryResult = NonNullable<
    Awaited<ReturnType<typeof getLabelsScope>>
>
export type GetLabelsScopeQueryError = AxiosError<unknown>

export const useGetLabelsScope = <
    TData = Awaited<ReturnType<typeof getLabelsScope>>,
    TError = AxiosError<unknown>
>(
    scope: string,
    params?: GetLabelsScopeParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getLabelsScope>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ?? getGetLabelsScopeQueryKey(scope, params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getLabelsScope>>
    > = ({ signal }) =>
        getLabelsScope(scope, params, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getLabelsScope>>,
        TError,
        TData
    >(queryKey, queryFn, {
        enabled: !!scope,
        ...queryOptions,
    }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

    query.queryKey = queryKey

    return query
}

/**
 * @summary Return a collection of labels appropriate for the user's search
 */
export const getLabelsSearch = (
    params?: GetLabelsSearchParams,
    options?: AxiosRequestConfig
): Promise<AxiosResponse<GetLabelsSearch200>> => {
    return axios.get(`/labels/search`, {
        ...options,
        params: { ...params, ...options?.params },
    })
}

export const getGetLabelsSearchQueryKey = (params?: GetLabelsSearchParams) => [
    `/labels/search`,
    ...(params ? [params] : []),
]

export type GetLabelsSearchQueryResult = NonNullable<
    Awaited<ReturnType<typeof getLabelsSearch>>
>
export type GetLabelsSearchQueryError = AxiosError<unknown>

export const useGetLabelsSearch = <
    TData = Awaited<ReturnType<typeof getLabelsSearch>>,
    TError = AxiosError<unknown>
>(
    params?: GetLabelsSearchParams,
    options?: {
        query?: UseQueryOptions<
            Awaited<ReturnType<typeof getLabelsSearch>>,
            TError,
            TData
        >
        axios?: AxiosRequestConfig
    }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey =
        queryOptions?.queryKey ?? getGetLabelsSearchQueryKey(params)

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getLabelsSearch>>
    > = ({ signal }) => getLabelsSearch(params, { signal, ...axiosOptions })

    const query = useQuery<
        Awaited<ReturnType<typeof getLabelsSearch>>,
        TError,
        TData
    >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
        queryKey: QueryKey
    }

    query.queryKey = queryKey

    return query
}
